<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sanskrit Handwriting Recognition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #0f172a; /* Slate-900 background */
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #drawingCanvas {
            border: 2px solid #3b82f6;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            touch-action: none; /* Crucial for better mobile drawing handling */
            background-color: white;
            /* Responsive sizing */
            max-width: 90vw;
            flex-grow: 1; /* Allow it to take up space */
            margin-bottom: 1rem;
        }
        .controls-bar {
            background-color: #1e293b;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            width: 90%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        #recognizedText {
            min-height: 8rem;
            border: 2px solid #6366f1; /* Indigo-500 */
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 1.5rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 90%;
            max-width: 800px;
        }
        .text-section {
            width: 90%;
            max-width: 800px;
            margin-top: 1rem;
        }
    </style>
</head>
<body>

    <div class="p-4 text-center">
        <h1 class="text-2xl font-bold text-white mb-1">Sanskrit Handwriting Recognizer</h1>
        <p id="status-message" class="text-sm text-gray-400">Mobile: Write in Devanagari. Desktop: Watch the recognized text.</p>
    </div>

    <!-- The Drawing Canvas -->
    <canvas id="drawingCanvas"></canvas>

    <!-- Controls -->
    <div class="controls-bar">
        <button id="recognizeButton" class="px-4 py-2 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 transition duration-150 shadow-lg flex items-center justify-center">
            <svg id="loadingSpinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Recognize Sanskrit
        </button>
        <button id="clearButton" class="px-4 py-2 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition duration-150 shadow-lg">
            Clear
        </button>
    </div>

    <!-- Recognized Text Display -->
    <div class="text-section">
        <p class="text-gray-400 text-sm mb-2">Recognized Text:</p>
        <div id="recognizedText" class="text-3xl">
            Draw some Devanagari characters above and press 'Recognize Sanskrit'.
        </div>
    </div>


    <script>
        // --- Configuration & State ---
        // Since the client is served by the same Node server, we use relative WebSocket URL
        const WS_SERVER_URL = window.location.host; 

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const recognizeButton = document.getElementById('recognizeButton');
        const clearButton = document.getElementById('clearButton');
        const recognizedTextDisplay = document.getElementById('recognizedText');
        const loadingSpinner = document.getElementById('loadingSpinner');

        let ws;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        const DRAW_COLOR = '#000000';
        const DRAW_SIZE = 20;

        // --- Canvas Initialization and Resizing ---
        function resizeCanvas() {
            // Set the canvas rendering size (high resolution for sharp drawing)
            canvas.width = 1200;
            canvas.height = 600;

            // Set the canvas CSS size (visible size on screen)
            canvas.style.width = '100%';
            canvas.style.height = 'auto'; 
            canvas.style.maxWidth = '600px';

            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = DRAW_COLOR;
            ctx.lineWidth = DRAW_SIZE;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);


        // --- WebSocket Connection Logic ---
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const url = protocol + WS_SERVER_URL;

            ws = new WebSocket(url);

            ws.onopen = () => {
                statusMessage.textContent = 'Status: Connected to Server.';
                statusMessage.classList.remove('text-red-400', 'text-yellow-400');
                statusMessage.classList.add('text-green-400');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'recognized_text') {
                        handleRecognizedText(data.text);
                    }
                } catch (e) {
                    console.error('Failed to parse incoming message:', e);
                }
            };

            ws.onclose = () => {
                statusMessage.textContent = 'Status: Disconnected. Reconnecting in 5s...';
                statusMessage.classList.remove('text-green-400');
                statusMessage.classList.add('text-red-400');
                setTimeout(connectWebSocket, 5000); 
            };
        }

        // --- Drawing Functionality ---

        // Draw a line segment locally
        function drawLine(x1, y1, x2, y2) {
            // Scale coordinates from the CSS client size to the internal canvas resolution
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            
            ctx.beginPath();
            ctx.moveTo(x1 * scaleX, y1 * scaleY);
            ctx.lineTo(x2 * scaleX, y2 * scaleY);
            ctx.stroke();
        }

        function clearCanvasLocally() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // --- Event Handlers (Mouse/Touch) ---

        function getCanvasPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            // Coordinates relative to the canvas CSS size
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            return { x, y };
        }

        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            const { x, y } = getCanvasPosition(e);
            
            lastX = x; 
            lastY = y; 
        }

        function moveDraw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const { x, y } = getCanvasPosition(e);

            // Draw locally
            drawLine(lastX, lastY, x, y);
            
            lastX = x;
            lastY = y;
        }

        function endDraw() {
            isDrawing = false;
        }

        // Attach listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', moveDraw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseout', endDraw);
        canvas.addEventListener('touchstart', startDraw);
        canvas.addEventListener('touchmove', moveDraw);
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        clearButton.addEventListener('click', () => {
            clearCanvasLocally();
            recognizedTextDisplay.textContent = 'Draw some Devanagari characters above and press \'Recognize Sanskrit\'.';
        });

        // --- Recognition Logic ---

        function setRecognitionState(isRecognizing) {
            recognizeButton.disabled = isRecognizing;
            loadingSpinner.classList.toggle('hidden', !isRecognizing);
            recognizeButton.textContent = isRecognizing ? 'Recognizing...' : 'Recognize Sanskrit';
        }

        recognizeButton.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // 1. Convert Canvas to Base64 Image
                const base64Image = canvas.toDataURL('image/png');
                
                // 2. Send the image to the server for recognition
                ws.send(JSON.stringify({ 
                    type: 'recognize_image', 
                    image: base64Image 
                }));
                
                // 3. Update UI
                recognizedTextDisplay.textContent = 'Sending image for recognition...';
                setRecognitionState(true);

            } else {
                recognizedTextDisplay.textContent = 'Error: WebSocket not connected.';
            }
        });

        function handleRecognizedText(text) {
            setRecognitionState(false);
            recognizedTextDisplay.textContent = text;
            
            // OPTIONAL: Clear the canvas after successful recognition
            clearCanvasLocally();
        }


        // Start the application
        connectWebSocket();
    </script>
</body>
</html>
