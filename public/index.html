<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sanskrit Handwriting OCR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #0f172a; /* Slate-900 background */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            touch-action: none; /* Prevents default mobile scrolling/zooming */
            border: 2px solid #3b82f6;
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .controls-bar {
            background-color: #1e293b;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            width: 90%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .text-section {
            width: 90%;
            max-width: 800px;
            margin-top: 1rem;
            margin-bottom: 2rem;
        }
        /* Mobile drawing container */
        .mobile-drawing-area {
            width: 90%;
            max-width: 600px;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>

    <!-- Desktop Display Container (Hidden on mobile) -->
    <div id="desktopContainer" class="hidden md:flex flex-col items-center justify-center p-8 h-screen w-full">
        <h1 class="text-4xl font-extrabold text-white mb-4">Sanskrit Live OCR Display</h1>
        <p class="text-lg text-gray-400 mb-8">
            Draw in Devanagari script on a mobile device to see the transcription here.
        </p>

        <!-- Live Recognized Text Display -->
        <div class="text-section md:w-3/4 lg:w-1/2">
            <p class="text-gray-300 text-xl font-semibold mb-3">Recognized Text:</p>
            <div id="recognizedTextDesktop" class="min-h-[12rem] bg-slate-800 border-4 border-indigo-500 text-purple-200 p-6 rounded-xl shadow-2xl flex items-center justify-center font-serif text-5xl break-words whitespace-pre-wrap">
                Waiting for input...
            </div>
            <p id="status-message-desktop" class="text-sm text-yellow-400 mt-4 text-center">Status: Connecting...</p>
        </div>
    </div>


    <!-- Mobile/Small Screen Drawing Interface (Hidden on desktop) -->
    <div id="mobileContainer" class="md:hidden flex flex-col items-center w-full pt-4">
        
        <div class="p-4 text-center">
            <h1 class="text-2xl font-bold text-white mb-1">Mobile Sanskrit Writer</h1>
            <p id="status-message-mobile" class="text-sm text-yellow-400">Status: Connecting...</p>
        </div>

        <!-- The Canvas Drawing Area -->
        <div class="mobile-drawing-area">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="controls-bar">
            <button id="recognizeButton" class="px-4 py-2 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700 transition duration-150 shadow-lg flex items-center justify-center">
                Recognize Sanskrit
            </button>
            <button id="clearButton" class="px-4 py-2 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition duration-150 shadow-lg">
                Clear
            </button>
        </div>

        <!-- Mobile Feedback Display -->
        <div class="text-section">
            <p class="text-gray-400 text-sm mb-2">Last Recognized Output:</p>
            <div id="recognizedTextMobile" class="min-h-8 bg-slate-800 border-2 border-slate-600 text-white p-3 rounded-lg text-lg text-center flex items-center justify-center whitespace-pre-wrap">
                Output here...
            </div>
        </div>
    </div>


    <script>
        // --- Configuration & State ---
        
        // IMPORTANT: Replace the placeholder with your actual Render URL (e.g., 'my-ocr-app.onrender.com').
        const FALLBACK_HOST_FOR_TESTING = "YOUR-RENDER-APP-NAME.onrender.com"; 

        let currentHost = window.location.host;
        
        if (!currentHost && !FALLBACK_HOST_FOR_TESTING.includes('YOUR-RENDER-APP-NAME')) {
            currentHost = FALLBACK_HOST_FOR_TESTING;
        }
        
        const WS_SERVER_URL = currentHost; 
        
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const statusMobile = document.getElementById('status-message-mobile');
        const statusDesktop = document.getElementById('status-message-desktop');
        const recognizeButton = document.getElementById('recognizeButton');
        const clearButton = document.getElementById('clearButton');
        const recognizedTextDesktop = document.getElementById('recognizedTextDesktop');
        const recognizedTextMobile = document.getElementById('recognizedTextMobile');

        let ws;
        let isDrawing = false;
        
        // --- Initialization and Canvas Setup ---

        function setupCanvas() {
            if (!canvas) return;
            
            // Set canvas size dynamically for mobile
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = canvas.width * 0.75; // Maintain a good aspect ratio

            ctx.lineWidth = 20; // Thick line for better OCR
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000000'; // Black ink
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Ensure white background

            // Redraw on resize (important for responsiveness)
            window.addEventListener('resize', () => {
                if (window.innerWidth < 768) { // Only resize if in mobile view
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const newWidth = parent.clientWidth;
                    canvas.width = newWidth;
                    canvas.height = newWidth * 0.75;
                    ctx.putImageData(imageData, 0, 0); // This is highly simplified and won't work well, but it prevents crashes.
                    
                    // Simple clear and redraw setup for mobile devices after resize
                    ctx.lineWidth = 20;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#000000';
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            });
        }


        // --- Drawing Logic (for mobile) ---

        function getPosition(event) {
            const rect = canvas.getBoundingClientRect();
            // Handle both mouse (desktop testing) and touch (mobile) events
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            // Scale coordinates based on canvas display size vs. internal resolution
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function startDrawing(e) {
            e.preventDefault(); 
            isDrawing = true;
            const { x, y } = getPosition(e);
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function draw(e) {
            e.preventDefault(); 
            if (!isDrawing) return;
            const { x, y } = getPosition(e);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.closePath();
        }
        
        function clearCanvas() {
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            recognizedTextMobile.textContent = 'Canvas cleared.';
        }


        // --- WebSocket Connection Logic ---
        function updateStatus(message, isError = false) {
            const defaultClass = 'text-yellow-400';

            if (statusMobile) statusMobile.textContent = 'Status: ' + message;
            if (statusDesktop) statusDesktop.textContent = 'Status: ' + message;
            
            [statusMobile, statusDesktop].forEach(el => {
                if (el) {
                    el.classList.remove('text-green-400', 'text-yellow-400', 'text-red-400');
                    el.classList.add(isError ? 'text-red-400' : defaultClass);
                }
            });
            if (!isError && message.includes('Connected')) {
                if (statusMobile) statusMobile.classList.add('text-green-400');
                if (statusDesktop) statusDesktop.classList.add('text-green-400');
            }
        }
        
        function connectWebSocket() {
            if (!WS_SERVER_URL || WS_SERVER_URL.includes('YOUR-RENDER-APP-NAME')) {
                 updateStatus('ERROR: Set FALLBACK_HOST_FOR_TESTING in JS to your Render URL.', true);
                 console.error("WS_SERVER_URL is invalid. Please set FALLBACK_HOST_FOR_TESTING in the JavaScript section with your actual Render URL to test the connection.");
                 return; 
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const url = protocol + WS_SERVER_URL;

            ws = new WebSocket(url);

            ws.onopen = () => {
                updateStatus('Connected to Server.', false);
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'display_text') {
                        handleReceivedText(data.text);
                    }
                } catch (e) {
                    console.error('Failed to parse incoming message:', e);
                }
            };

            ws.onclose = () => {
                updateStatus('Disconnected. Reconnecting in 5s...', true);
                setTimeout(connectWebSocket, 5000); 
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
                updateStatus('Connection Error. Check network/server.', true);
            };
        }

        // --- Action Handler ---

        function handleRecognize() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Convert the canvas content to a Base64 PNG image
                const base64Image = canvas.toDataURL('image/png');
                
                // Send the image to the server for recognition
                ws.send(JSON.stringify({ 
                    type: 'recognize_image', 
                    image: base64Image 
                }));
                
                recognizedTextMobile.textContent = 'Sending image for OCR...';

            } else {
                recognizedTextMobile.textContent = 'Error: WebSocket not connected.';
            }
        }

        function handleReceivedText(text) {
            // Update the dedicated desktop display
            recognizedTextDesktop.textContent = text;
            
            // Update the mobile display feedback (for confirmation)
            recognizedTextMobile.textContent = 'Result: ' + text;
        }


        // --- Setup Listeners ---
        window.addEventListener('load', () => {
            connectWebSocket();
            
            if (window.innerWidth < 768) {
                setupCanvas();
                
                // Touch events for mobile drawing
                canvas.addEventListener('touchstart', startDrawing);
                canvas.addEventListener('touchmove', draw);
                canvas.addEventListener('touchend', stopDrawing);
                
                // Mouse events for desktop/preview drawing
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('mouseout', stopDrawing);

                recognizeButton.addEventListener('click', handleRecognize);
                clearButton.addEventListener('click', clearCanvas);
            }
        });
    </script>
</body>
</html>
